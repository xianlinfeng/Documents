input: k, s^0, P^1
output: S^*

begin:
1.  read problem p^1, 
2.  read solution s^0                               -->    SCIPreadSol()
3.  check s^0 is feasible to P^1 or not .
4.      if yes: return s^*
5.  else: assign \alpha <-- k * c^Ts^0
6.      create new variables y
7.      p^2 <-- add new constraints to p^1
8.      p^2 <-- add penalty function to p^2
9.  start iteration:
        get s^r on every r-th iteration.            --> solve the problem to stopping criation 
                                                            SCIP_CALL( SCIPsetRealParam(scip, "limits/time", 3600) ) 

        decreate \alpha
10. return s^r 



        // SCIP_CALL(SCIPcreate);  //create a SCIP object
        // SCIP_CALL(SCIPcreateProb); // create the scip problem
        // SCIP_CALL(SCIPcreateVar); // create varialbes
        // SCIP_CALL(SCIPaddVar); // add the variables to the problem
        // SCIP_CALL(SCIPcreateConsLinear); // create linear constraints 
        // SCIP_CALL(SCIPaddConsLinear);// add the constraints into the problem
        //         SCIP_CALL(SCIPreleaseCons); // release the constraint affter adding them into the problem
        // SCIP_CALL(SCIPsolve);  //  initiate the solution process  

        // scip_call(SCIPreleaseVar()); // ralease the variables after solving